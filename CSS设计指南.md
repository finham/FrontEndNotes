# CSS设计指南

[TOC]

## 1、HTML标记与文档结构

CSS的用途就是为 HTML标记添加样式。

因为用HTML来标记内容是做任何网页的头一件 事。所谓内容，就是你想要传达给读者的那些东西，比如文字、图片、音频和视频。

用 HTML标记内容的目的是为了赋予网页语义（semantic）。换句话说，就是要给你的网页内容赋予某些用户代理（user agent）能够理解的含义。

> 我们平常用的浏览器、 给视障用户朗读网页的屏幕阅读器，以及搜索引擎放出的 Web爬虫都是用户代理， 它们需要显示、朗读和分析网页。

目前，HTML一共有 114 个标签，但按照 80/20 原则，使用其中 25个左右的标签就可以满足 80%的标记需要。要想知道和了解 HTML标签， 可以看看本书网站：http://www.stylinwithcss.com。

在 HTML5标准出现之前，创建页面的结构只能使用一些几乎没有什么语义的标签， 比如<div>和<span>。而现在，我们有了一套专门的结构化标签。

### 1.1 基础

对于每个包含内容的元素（比如标题、段落和图片），根据它所包含的内容是不是文本，有两种不同的方式给它们加标记，一种是使用闭合标签（例如 h1/h2/p等等），另一种是使用非闭合标签（例如img等(alt属性可以读出内容)）。

> 块级标签 
>
>  <h1>-<h6> ：6级标签，<h1>表示最重要 
>
>  <p>：段落
>
>  <ol>：有序列表 
>
>  <li>：列表项 
>
>  <blockquote>：独立引用
>
> 行内标签 
>
>  <a>：链接（anchor，锚） 
>
>  <img>：图片 
>
>  <em>：斜体 
>
>  <strong>：重要 
>
>  <abbr>：简写
>
>  <cite>：引证 
>
>  <q>：文本内引用

### 1.2 HTML文档

浏览器把包含内容的元素在页面中自上而下地一一排列，起点是页面的左上角。

虽然标题和段落是上下堆叠在一起的，但链接和图片却是并排显示的。为什么会这样呢？因为标题和段落是块级元素，而链接和图片是行内元素。

> 块级元素（比如标题和段落）会相互堆叠在一起沿页面向下排列，每个元素分别占一行。
>
> 而行内元素（比如链接和图片）则会相互并列，只有在空间不足以并列的情 况下才会折到下一行显示。

文档流：HTML元素会按照它们各自在标记中 出现的先后顺序，依次从页面上方“流向”下方。几乎所有 HTML元素的 display 属性值要么为 block，要么为 inline。最明显的一 个例外是 table 元素，它有自己特殊的 display 属性值。

无论你想了解哪个 HTML元素，第一个要问的问题都应该是：它是块级元素，还是 行内元素？知道了这一点之后，就可以在编写标记的时候，预想到某个元素在初始状态下是如何定位的，这样才能进一步想好将来怎么用 CSS重新定位它。

块级元素的元素盒子比它们包含的文本要大一些。每个盒子的高度比内容稍微高一点，而宽度跟浏览器窗口一样宽！在我们这个页面中，所有块级元素的父元素都是 body，而它的宽度默认与浏览器窗口一样宽（当然有少量边距）。因此，所有块级元素就与浏览器窗口一样宽了。

到这，相信你就能理解为什么块级元素始终会占一行了。对了，就是因为它们始终会保持与浏览器窗口同宽。这样一来，一个块级元素旁边也就没有空间容纳另一个块级元素了。

行内元素盒子的行为与块级元素盒子的行为正好相反。行内元素盒子会“收缩包裹”其内容，并且会尽可能包紧。

### 1.3 文档对象模型DOM

DOM 是从浏览器的视角来观察页面 中的元素以及每个元素的属性，由此得出这些元素的一个家族树。通过DOM，可以确定元素之间的相互关系。在 CSS 中引用DOM中特定的位置，就可以选中相应的 HTML元素，并修改其样式属性。

通过 HTML 标记来构建 DOM，然后在页面初次加载和用户与页面交 互时，使用 CSS来修改DOM。

## 2、CSS工作原理

本章，我们来说一说

1. CSS规则怎么为 HTML添加样式
2. 解释层叠的工作机制——当元素的同一个样式属性有多 种样式值的时候，CSS就要靠层叠机制来决定最终应用哪种样式。

### 2.1 CSS规则

```css
h1, h2, h3 {color:blue; font-weight:bold;}
```

假设，你在写完前面那条规则后，又想只把 h3 变成斜体，那可以再为 h3 写一条规则：

```css
h1, h2, h3 {color:blue; font-weight:bold;} 
h3 {font-style:italic;}
```

### 2.2 上下文选择符

你想分别给 article 和 aside 中的段落 文本，分别设置不同的字号。像这种“基于位置”变换某个标签样式的问题，可以 用上下文选择符来解决。

上下文选择符的格式如下：

```css
标签1 标签2 {
    声明
}
```

其中，标签 2 就是我们想要选择目标，而且只有在标签 1 是其祖先元素（不一定是父元素）的情况下才会被选中。

上下文选择符，严格来讲（也就是 CSS 规范里），叫后代组合式选择符（descendant combinator selector），就是一组以空格分隔的标签名。用于选择作为指定祖先元素后代的标签。

```css
article p {
    font-weight:bold;
}
```

这个例子中的上下文选择符表明，只有是article后代的p元素才会应用后面的样式。 换句话说，上面这条规则的目标是位于 article 上下文中的 p 元素。

还可以更具体：

```css
article h1 em {
    color:green;
}
```

这里选择符的意思就是说：“选中的 em 必须有一个祖先是 h1，后者进而还要有一个祖先是 article。”

#### 子选择符>

```css
标签1 > 标签2
```

标签 2必须是标签 1的子元素，或者反过来说，标签1必须是标签2的父元素。

与常规的上下文选择符不同，这个选择符中的标签1不能是标签2的父元素之外的其他祖先元素。

#### 紧邻同胞选择符+

```css
标签1 + 标签2 
```

标签2必须紧跟在其同胞标签1的后面。

#### 一般同胞选择符~

```css
标签1 ~ 标签2
```

标签 2必须跟（不一定紧跟）在其同胞标签 1后面。

#### 通用选择符*

通用选择符*（常被称为星号选择符）是一个通配符，它匹配任何元素，因此下面这条规则

```css
* {
    color:green;
}
```

会导致所有元素（的文本和边框）都变成绿色。

不过，一般在使用*选择符时，都会同时使用另一个选择符，比如：

```css
p * {
    color:red;
}
```

这样只会把 p 包含的所有元素的文本变成红色。

**这个选择符有一个非常有意思的用法，即用它构成非子选择符**，比如：

```css
section * a {
    font-size:1.3em;
}
```

任何是 section 孙子元素，而非子元素的 a 标签都会被选中。至于 a 的父元素是什么，没有关系。

只有一个标签名的选择符会选中页面中所有相同标签的实例。而通过上下文 选择符，则可以指定标签必须具备相应的祖先或同胞。

### 2.3 类选择符

可以给 id 和 class 属性设定任何值，但不能以数字或特殊符号开头。

```css
p.specialtext {color:red;}
```

CSS规则只选择带 specialtext 类的段落。像这样组合标签 名和类选择符，可以让你更精确地选择特定的标签。

```css
p.specialtext span {font-weight:bold;}
```

包含它的 span 位于一个带有 specialtext 类的段落中

可以给元素添加多个类，比如：

```html
<p class="specialtext featured">Here the span tag <span>may or may not</span> be styled.</p>
```

多个类名，如这里的 specialtext 和 featured，放在同一对引号里，用空格分隔。实 际上，更准确的说法，就应该是 HTML的 class 属性可以有多个空格分隔的值。

要选择同时存在这两个类名的元素，可以这样写：

```css
.specialtext.featured {
    font-size:120%;
}
```

> 注意：CSS 选择符的两个类名之间没有空格，因为我们只想选择同时具有这两个类 名的那个元素。如果你加了空格，那就变成了“祖先/后代”关系的上下文选择符了。

每个类名分别用一个 HTML class 属性的做法是常见的错误，正确的做法是像上面的代码那样，只用一个 class 属性，但给它设定多个值。

### 2.4 ID选择符

```html
<p id="specialtext">This is the special text.</p>
```

那么，相应的 ID选择符就是这样的：

```css
#specialtext {CSS 样式声明}
```

或者这样的：

```css
p#specialtext {CSS 样式声明}
```

id的另一种用途：用于同页面内的导航

```html
<a href="#bio">Biography</a>
```

看到 href 属性值开头的#了吗？它表示这个链接的目标在当前页面中，因而不会触发浏览器加 载页面（如果没有#，浏览器就会尝试加载bio 目录下的默认页面了）。

使用与 CSS 选择符里相同的 #ID 名语法，可以把链接导航到同一页面中的目标ID。

在这个页面的下方，应该有对应的目标元素。

```html
<h3 id="bio">Biography</h3> 
<p>I was born when I was very young…</p>
```

用户单击前面的链接时，页面会向下滚动到 ID 值为 bio 的 h3 元素的位置。如果链接的 href 属性里只有一个#，那么点击该链接会返回页面顶部。

```html
<a href="#">Back to Top</a>
```

换句话说，要写一个“返回顶部”链接，根本不需要 ID 为#的目标元素。

> 另外，如果你暂时不知道某个 href 应该放什么 URL，也可以用#作为占位符，但不能把该属性留空。因为 href 属性值为空的链接的行为跟正常链接不一样。
>
> 这样，团队中的其他人将来可以用中间层（比如PHP）变量替换#，以便动态接收来自数据库的 URL。

### 2.5 什么时候用ID，什么时候用类

ID的用途是在页面中唯一地标识一个元素。正因为如此，同一个页面中的每一个 ID 属性，都必须有独一无二的值（名字）。好吧，换一个角度讲，每个 ID 名在页面中都只能用一次。

利用唯一 ID，可以在 CSS中方便地定位到这个元素，以及它的子元素。到了后面读 者会发现，我经常会给页面中每个顶级区域都添加一个 ID，从而得到非常明确的上 下文，以便编写 CSS时只选择嵌套在相应区域内的标签。

类的目的是为了标识一组具有相同特征的元素，比如本章前面例子中的那个 specialtext 类。

> 要避免 Web开发专家 Jeffrey Zeldman 说的“类泛滥——标记中的麻疹”出现。什么意思呢？ 就是说你不要像使用 ID 一样，每个类都指定一个不同的类名，然后再为每个类编写规则。如果你确实有这种随意使用类的习惯，那说明你可能像大多数对 CSS 充满激情的初学者一样，还不了解继承和上下文选择符的作用。于是，你可能会给每个标签都重复写同样的样式（比如为 页面中很多标签分别指定相同的字体）。
>
> **实际上，继承和上下文**选择符能让不同的标签共享样式，从而降低你需要编写和维护的 CSS 量。

### 2.6 属性选择符

基于 HTML标签的属性选择元素。有两种形式：

#### 属性名选择符

```css
标签名[属性名]
```

选择任何带有属性名的标签名。比如：

```css
img[title] {
    border:2px solid blue;
}
```

会导致像下面这个**带有 title 属性**的HTML img 元素显示 2像素宽的蓝色边框，至于 title 属性有什么值，无关紧要，只要有这个属性在就行啦。

```html
<img src="images/yellow_flower.jpg" title="yellow flower" alt="yellow flower" />
```

什么情况下会用到这个属性选择符呢？

比如，可以在用户鼠标移动到这些图片上时， 此时浏览器会显示一个（利用 title 属性中的文本生成的）提示条。一般来说，人们经常给 alt 和 title 属性设定相同的值。alt 属性中的文本会在图片因故未能加载 时显示，或者由屏幕阅读器朗读出来。而 title 属性会在用户鼠标移动到图片上时， 显示一个包含相应文本的提示。

#### 属性值选择符

格式：

```css
标签名[属性名="属性值"]
```

> 在 HTML5中，属性值的引号可加可不加，在此为了清楚起见，我们加了。

这个选择符可以让你控制到属性的值是什么。例如，这条规则：

```css
img[title="red flower"] {
    border:4px solid green;
}
```

在图片的 title 属性值为 red flower 的情况下，才会为图片添加边框。换句话说， 下面这个 img 元素就会被加上边框。

```html
<img src="images/red_flower.jpg" title="red flower" alt="red flower" />
```

当然，属性选择符还有其他形式，感兴趣的话，就请访问 http://www.stylinwithcss.com吧。

### 2.7 伪类

使用CSS还可以在某些事件发生时，改变某些元素的样式，比如用户鼠标悬停在一个链接上。而这就要靠伪类来实现了。

伪类这个叫法源自它们与类相似，但实际上并没有类会附加到标记中的标签上。伪类分两种：

* UI伪类会在 HTML元素处于某个状态时（比如鼠标指针位于链接上），为该元素应用 CSS样式。
* 结构化伪类会在标记中存在某种结构上的关系时（如某个元素是一组元素中的第一个或最后一个），为相应元素应用 CSS 样式。

#### UI伪类

最常使用 UI伪类的元素是链接（a 元素），利用 UI 伪类，链接可以在用户鼠标悬停时改变文本颜色，或者去掉文本的下划线。此外，还可以有其他响应方式，比如悬停时显示一个信息面板。

##### 链接伪类

针对链接的伪类一共有4个，因为链接始终会处于如下4种状态之一。

* Link：此时，链接就在那儿等着用户点击。
* Visited。用户此前点击过这个链接。
* Hover。鼠标指针正悬停在链接上。
* Active。链接正在被点击（鼠标在元素上按下，还没有释放）。

以下就是这些状态对应的 4个伪类选择符（使用了 a 选择符和一些示例声明）：

* a:link {color:black;}
* a:visited {color:gray;} 
* a:hover {text-decoration:none;} 
* a:active {color:red;}

> 选择符中与众不同的:（冒号）好像在向我们宣示：“我是一个伪类！”
>
> 一个冒号（:）表示伪类，两个冒号（::）表示CSS3新增的伪元素。尽管浏览器目前都支持对CSS 1和CSS 2的伪元素使用一个冒号，但希望你能习惯于用双冒号代替单冒号，因为这些单冒号的伪元素最终可能都会被淘汰掉。更多相关信息，可以 参见这里：http://www.w3.org/TR/2005/WD-css3- selectors-20051215/#pseudo-elements。

不知道你有没有注意：链接在初始状态时是黑色（默认带下划线）。当鼠标移到上面时（悬 停状态），链接的下划线消失，颜色仍然是黑色。当用户在链接上按下鼠标时（活动 状态），链接变成红色。而在链接被点击后，也就是鼠标在链接上按下，又在链接上 释放后，会触发浏览器打开 URL，此后（或者更准确地说，到浏览器访问历史中的 这个 URL过期或被用户删除之前），链接会一直显示为灰色。

不一定非得把这 4个状态都写出来。如果你只想定义:link 和:hover 状态，没问题， 大多数情况下这也足够了。但如果你有一个长长的目录链接，那么用稍浅一些的颜 色显示出那些已经访问过（即点击过）的链接，对用户会很有帮助。然而，修改导航条 visited 状态的颜色就没有什么意义了。

**我一般就定义一个 a 状态和一个:hover 状态，后者就是为了让用户（在鼠标悬停时） 知道相应的元素是不是可以点。**

以这种方式为链接的不同的状态添加样式是不错，但要发挥这些链接伪类的真正 威力，还是得把它们用到上下文选择符中。这样，就可以让不同区块内的链接具 有不同的外观和行为了。

注意，有些伪类可以用于任何元素，而不仅仅是 a 元素。比如，下面这条规则能让段落背景在鼠标悬停时变成灰色：

```css
p:hover {
    background-color:gray;
}
```

##### :focus伪类

```css
e:focus //在这个以及后续的例子中，e 表示任何元素，如 p、h1、section，等等。
```

表单中的文本字段在用户单击它时会获得焦点，然后用户才能在其中输入字符。

下面的规则：

```css
input:focus {
    border:1px solid blue;
}
```

会在光标位于 input 字段中时，为该字段添加一个蓝色边框。这样可以让用户明确地知道输入的字符会出现在哪里。

##### :target伪类

```css
e:target
```

如果用户点击一个指向页面中其他元素的链接，则那个元素就是目标（target），可以用:target 伪类选中它。

对于下面这个链接

```html
<a href="#more_info">More Information</a>
```

位于页面其他地方、ID为 more_info 的那个元素就是目标。该元素可能是这样的：

```html
<h2 id="more_info">This is the information you are looking for.</h2>
```

那么，如下 CSS规则：

```css
#more_info:target {background:#eee;}
```

会在用户单击链接转向 ID为 more_info 的元素时，为该元素添加浅灰色背景。

> 维基百科在其引证中大量使用了:target 伪类。维基百科的引证链接就是正文里那些不起眼的数字链接。引证本身则位于长长的页面的最下方。如果没有:target 应用的突出显示，很难知道你点击的链接对应着一大堆引证中的哪一个。

#### 结构化伪类

结构化伪类可以根据标记的结构应用样式，比如根据某元素的父元素或前面的同胞元素是什么。

##### :first-child和:last-child

```css
e:first-child 
e:last-child
```

:first-child 代表一组同胞元素中的第一个元素，而:last-child 则代表最后一个。

比如，把下面的规则

```css
ol.results li:first-child {
    color:blue;
}
```

应用给以下标记：

```html
<ol class="results"> 
    <li>My Fast Pony</li> 
    <li>Steady Trotter</li> 
    <li>Slow Ol' Nag</li>
</ol>
```

文本“My Fast Pony”就会变成蓝色。如果选择符改成这样：

```css
ol.results li:last-child {
    color:red;
}
```

那变成红色的文本就是“Slow Ol’ Nag”了。

##### :nth-child

```css
e:nth-child(n) 
```

e 表示元素名，n 表示一个数值（也可以使用 odd 或 even）。

例如， 

```css
li:nth-child(3)
```

会选择一组列表项中的每个第三项。

:nth-child 伪类最常用于提高表格的可读性，比如像第 6 章中那样，对表格的所有行交替应用不同颜色。

还有其他一些结构化伪类，完整的信息请参考这里：http://www.stylinwithcss.com。

### 2.8 伪元素

顾名思义，伪元素就是你的文档中若有实无的元素。以下我们介绍几个最有用的伪 元素，其他伪元素请参考 http://www.stylinwithcss.com。

#### ::first-letter 

```css
e::first-letter
```

比如，以下 CSS规则：

```css
p::first-letter {font-size:300%;}
```

可以得到如图 2-18所示的段落首字符放大的效果。

> 如果不用伪元素创建这个首字符放大效果，必须手工给该字母加上<span>标签， 然后再为该标签应用样式。而伪元素实际上是替我们添加了无形的标签。

#### ::first-line

可以选中文本段落（一般情况下是段落）的第一行。例如

```css
p::first-line {font-variant:small-caps;}
```

可以把第一行以小型大写字母显示，见图 2-19。

> 注意，::first-line 伪元素的长度会随浏览器窗口大小的变化而改变。

#### ::before和::after

可用于在特定元素前面或后面添加特殊内容。

以下标记

```html
<p class="age">25</p>
```

和如下样式

```css
p.age::before {
    content:"Age: ";} 
p.age::after {
    content:" years.";
}
```

能得到以下结果：

```console
Age: 25 years.
```

如果标签中的内容是通过数据库查询生成的结果，那么用这种技巧再合适不过了。 因为所有结果都是数字，使用这两个伪元素可以在把数字呈现给用户时，加上说明性文字。

这个例子展示了对::before 和::after 伪元素很基本又很实用的应用。后面我还会给大家展示这两个伪元素的其他用法，比如在应用它们的元素外面附着一个动态的新元素，从而得到一种有趣的布局效果。
> 搜索引擎不会取得伪元素的信息（因为它在标记中并不存在）。因此，不要通过伪元素添加你想让搜索引擎索引的重要内容。

在一个较大的样式表中，可能会有很多条规则都选择同一个元素的同一个属性。比如，一个带有类属性的段落，可能会被一条以标签名作选择符的规则选中并指定一种字体，而另一条以该段落的类名作选择符的规则却会给它指定另一种字体。我们知道，字体属性在任意时刻都只能应用一种设定，那此时该应用哪种字体呢？为解决类似的冲突，确定哪条规则“胜出”并最终被应用，CSS提供了三种机制：继承、层叠和特指。接下来的三节，就分别讨论这三种机制。

### 2.9 继承

CSS 中的祖先元素会向后代传递一样东西：CSS 属性的值。

还记得吗，我们在第 1 章讲文档层 次结构时提到过，body 是所有元素的老祖宗，所有标签都是它的后代。那么由于 CSS 继承的约定，如果我们为 body 像下面一样写一条规则：

```css
body {
    font-family:helvetica, arial, sans-serif;
}
```

那么，文档中的所有元素，无论它在层次结构中多么靠下，都将继承这些样式，以 Helvetica字体（或者在Helvetica字体无效时以其他字体代替）显示各自包含的文本。

继承给我们带来的效率是显而易见的，全站的主字体只要在某个上层元素上指定即可，无须在每一个标签上分别指定。而对于个别想使用不同字体的元素，只要个别设定 font-family 属性就好了。

CSS中有很多属性是可以继承的，其中相当一部分都跟文本有关，比如颜色、字体、字号。然而，也有很多 CSS属性不能继承，因为继承这些属性没有意义。这些不能继承的属性主要涉及元素盒子的定位和显示方式，比如边框、外边距、内边距。

> 举个例子吧：假设我们想创建一个边栏，在其中放一组链接。为此，我们用 nav 元素嵌套该组链接，并给 nav 应用了一种字号和一个边框效果，比如 2 像素宽的红色边框。不难想象，nav 中的所有链接都继承它的字号很正常，可要是也继承它的边框就不合适了。当然，这些链接不会继承边框效果，因为 border 属性不能继承。

由于字体和文本样式是可以继承的，所以在使用相对字体单位（如百分比和 em）时 要格外小心。如果某个标签的字体大小被设置为 80%，而它的一个后代的字体大小 也被设置为 80%，那么该后代中文本最终的字体大小将是 64%（80%的 80%）。这有 时候可能并不是你想要的结果。第 4章我们会详细介绍绝对和相对大小的利弊。

### 2.10 层叠

层叠，就是层叠样式表中的层叠， 是一种样式在文档层次中逐层叠加的过程，目的是让浏览器面对某个标签特定属性值的多个来源，确定最终使用哪个值。

层叠是CSS的核心机制，理解了它才能以最经济的方式写出最容易改动的 CSS，让 文档外观在达到设计要求的同时，也给用户留下一些空间，让他们能根据需要更改文档的显示效果（比如整体调整字号）。

#### 样式来源

样式有多处来源。首先，如果告诉你浏览器有一个默认的样式表，你应该不会感到 奇怪，因为你还没有写一行 CSS呢，每个标签已经带了一定的样式。h1 是不是粗体，字号还挺大？em 是不是斜体？列表呢，是不是缩进而且还带项目符号或编号？

然后，有一个用户样式表。没错，用户也可以提供样式表，尽管这样的用户不多见。 这个选择对于视障用户很有用，他们可以通过用户样式表，强制浏览器加载的所有 网站都以更大的字号，更容易分辨的颜色显示内容。比如，某个视障用户可以增加如下样式：

```css
body {
    font-size:200%;
}
```

这样就把字号调大了一倍，继承同样也会起作用。

再有，就是作者样式表，也就是网页设计师（你）写的样式表。前面我们已经讲了作者给网页添加样式的三种方法：链接样式、嵌入样式和行内样式。

以下就是浏览器层叠各个来源样式的顺序：

1. 浏览器默认样式表
2. 用户样式表
3. 作者链接样式表（按照它们链接到页面的先后顺序）
4. 作者嵌入样式
5. 作者行内样式

浏览器会按照上述顺序依次检查每个来源的样式，并在有定义的情况下，更新对每个标签属性值的设定。整个检查更新过程结束后，再将每个标签以最终设定的样式显示出来。

举例来说，如果作者的链接样式表将 p 的字体设定为 Helvetica，而页面中有一条嵌入规则以相同的选择符把字体设定为 Verdana，那么段落文本最终会以 Verdana字体 显示。因为浏览器是在读取链接样式表之后读取嵌入样式。但要是用户和作者样式表都没有为段落指定字体，就会使用浏览器默认样式表中指定的 Times。

#### 层叠规则

层叠规则一：找到应用给每个元素和属性的所有声明。浏览器在加载每个页面时， 都会据此查到每一条 CSS规则，标识出所有受到影响的 HTML元素。

层叠规则二：按照顺序和权重排序。浏览器依次检查 5个来源，并设定匹配的属性。 如果匹配的属性在下一个来源也有定义，则更新该属性的值，如此循环，直到检查 完页面中所有标签受影响属性的全部 5个来源为止。最终某个属性被设定成什么值，就用什么值来显示。

声明也可以有权重。可以像下面这样为单独的声明增加权重：

```css
p {
    color:green !important; 
    font-size:12pt;
}
```

空格!important 分号（;）用于加重声明的权重。

这条规则加重了将文本设置为绿色的权重。于是，就算层叠的下一来源给段落设定了其他颜色，最终的颜色值仍然还是绿色。说到底，就是一种特权，相当于你下了命令：就应用这个样式啦，其他来源一概不用考虑。不过，在使用这个特权之前， 一定要知道你的这个!important 声明，很可能会让用户的个人设定不起作用，而用户的设定对他可能还非常重要。每次当你有使用这个特权的冲动时，最好先静下心来仔细分析一下自己的 CSS，多数情况下都应该可以想出一种更好的替代方案。

> 就我个人而言，我是基本上不用 !important 声明的。

层叠规则三：按特指度排序。除了有点拗口之外，特指度（specificity）其实表示一条规则有多明确。如果没有特指度的考量，那为了让恰当的样式起作用，恐怕我们就免不了要频繁变换样式表中规则的顺序了。

我们知道，如果某个样式表中包含如下规则：

```css
p {
    font-size:12px;
}
p.largetext {
    font-size:16px;
}
```

那么下面的段落：

```html
<p class="largetext">A bit of text</p>
```

将显示16像素高的文本，因为第二条规则的选择符既包含标签名，也包含类名，所以意义更明确（特指度更高），结果第二条规则会覆盖第一条规则中的同名属性。这个例子似乎太明显了，如果还是对同一个段落，有如下样式呢？

```css
p {font-size:12px;} 
.largetext {font-size:16px;}
```

答案是尽管两条规则都匹配同一个标签，但使用类选择符的规则胜出，文本还是 16 像素高。为什么呀？因为类名选择符比普通的标签选择符具有更高的特指度。一条规则的特指度，由它的选择符中包含多少个标签、类名和 ID决定。

#### 计算特指度

下面我们具体讲一讲怎么计算选择符的特指度。首先，有一个简单的记分规则，即 对每个选择符都要按下面的“ICE”公式计算三个值：I - C - E

> ICE并非真正的三位数，只不过大多情况下把结果看成一个三位数没有问题，三位数 最大的胜出。但是，千万得知道 0-1-12与 0-2-0相比，仍然是 0-2-0的特指度更高。

三个字母间的短横线是分隔符，并非减号。针对这个公式的计分办法如下：

1. 选择符中有一个 ID，就在 I的位置上加 1；
2. 选择符中有一个类，就在 C的位置上加 1；
3. 选择符中有一个元素（标签）名，就在E的位置上加 1；
4. 得到一个三位数。

好了，下面通过几个例子来理解特指度。

| 选择符                        | 特指度           |
| ----------------------------- | ---------------- |
| p                             | 0-0-1 特指度=1   |
| p.largetext                   | 0-1-1 特指度=11  |
| p#largetext                   | 1-0-1 特指度=101 |
| body p#largetext              | 1-0-2 特指度=102 |
| body p#largetext ul.mylist    | 1-1-3 特指度=113 |
| body p#largetext ul.mylist li | 1-1-4 特指度=114 |

层叠规则四：顺序决定权重。如果两条规则都影响某元素的同一个属性，而且它们的特指度也相同，则位置最靠下（或后声明）的规则胜出。

> 建议大家参考本书一位读者“流年”的文章“CSS优先级特性”：http://liunian.info/css-specificity.html。

总结了一个简化版的层叠规则（见下面“查 理版简单层叠要点”），不仅适用于任何情况，而且也更容易记住。

> 在这个查理版里，只要记住三条规则就够了。这三条规则适合所有情况。
>
> 规则一：包含 ID 的选择符胜过包含类的选择符，包含类的选择符胜过包含标签名的选择符。
>
> 规则二：如果几个不同来源都为同一个标签的同一个属性定义了样式，行内样式胜过嵌入样 式，嵌入样式胜过链接样式。在链接的样式表中，具有相同特指度的样式，后声明的胜过先声明的。
>
> 规则一胜过规则二。换句话说，如果选择符更明确（特指度更高），无论它在哪里，都会胜出。
>
> 规则三：设定的样式胜过继承的样式，此时不用考虑特指度（即显式设定优先）。下面简单 解释一下规则三。比如下面的标记 
>
> <div id="cascade_demo"> <p id="inheritance_fact">Inheritance is <em>weak</em> in the Cascade</p>
> </div> 
>
> 和下面的规则
> div#cascade_demo p#inheritance_fact {color:blue;} 
>
> 2 - 0 - 2 （高特指度）
>
> 会导致单词“weak”变成蓝色，因为它从父元素 p 那里继承了这个颜色值。 
>
> 但是，只要我们再给 em 添加一条规则
>
> em {color:red;} 
>
> 0 - 0 - 1 （低特指度）
>
> em 就会变成红色。因为，虽然它的特指度低（0-0-1），但 em 继承的颜色值，会被为它明确（显式）指定的颜色值覆盖，就算（隐式）遗传该颜色值的规则的特指度高（2-0-2）也没有用。

### 2.11 规则声明

我们知道一个声明包含两部分：属性和值。属性指出要影响元素的哪个方面（颜色、高度，等等），而值表示把属性设定 为什么（绿色、12px，等等）。

CSS属性值主要分以下三类。

* 文本值。例如，font-weight:bold声明中的 bold就一个文本值。文本值也叫做关键字。 
* 数字值。数字值后面都有一个单位，例如英寸或点。在声明 font-size:12px 中，12 是数字值，而 px 是单位（像素）。如果数字值为 0，那么就不用带单位了。 绝对数字和相对数字。
* 颜色值。颜色值可以用几种不同的格式来写，包括RGB（Red, Green, Blue，红绿蓝）、 HSL（Hue, Saturation, Luminance，色相，饱和度，亮度）和十六进制值（例如 color:#336699）。

## 3、定位元素

盒模型、position和display属性、float和clear元素

可见的页面版式主要由三个属性控制：

* position 属性：控制页面上元素间的位置关系；
* display 属性：控制元素是堆叠、并排，还是根本不在页面上出现；
* float 属性：提供控制的方式，以便把元素组成成多栏布局。

我们先从每个元素盒子的属性开始吧。这些属性可以分成三组：

* 边框（border）。可以设置边框的宽窄、样式和颜色。
* 内边距（padding）。可以设置盒子内容区与边框的间距。
* 外边距（margin）。可以设置盒子与相邻元素的间距。

混合使用这三种粒度的简写属性达成设计目标是很常见的。比如说吧，我想为盒子的上边和下边添加 4 像素宽的红色边框，为左边添加 1 像素宽的红色边框，而右边没有边框。可以这样写：

```css
{border:4px solid red;} /* 先给 4 条边设置相同的样式 */ 
{border-left-width:1px;} /* 修改左边框宽度 */ 
{border-right:none;} /* 移除右边框 */
```

在实际开发的时候，为了看清楚 margin 和 padding 的实际效果，可以临时设定盒子的边框。默认情况下，边框的三个相关属性的值分别为 border-width:medium;、 border-style:none;、border-color:black;。由于 border-style 的默认值是 none， 所以不会显示盒子的边框。为了快速地把盒子边框显示出来，可以这样写一条规则：

```css
p {
    border:solid 1px;
}
```

推荐大家把下面这条规则作为样式表的第一条规则：

```css
* {margin:0; padding:0;}
```

这条规则把所有元素默认的外边距和内边距都设定为零。把这条规则放到样式表里后，所有默认的外边距和内边距都会消失。然后，你可以为那些真正需要外边距的元素再添加外边距。稍后我们会介绍，不同浏览器默认的内边距和外边距也不一样，特别是对表单和列表等复合元素。

在这种情况下，用前面那条规则“中和”默认值，然后再根据需要添加，则会在各浏览器上获得一致的效果。

> 我在自己的项目中使用了 Eric Meyer 写的重置样式表 reset.css。这个样式表不仅重置了外 边距和内边距，还对很多元素在跨浏览器显示时的外观进行了标准化。 至于 Eric 为什么要 写一个涉及面如此之广的重置样式表，可以参考他的文章 http://meyerweb.com/eric/ thoughts/2007/04/18/reset-reasoning，reset.css 的下载地址是 http://meyerweb. com/ eric/tools/css/reset。

### 3.1 叠加外边距

垂直方向上的外边距会叠加，这可是你必须得知道的一件事。本节就来解释一下什 么叫外边距叠加，为什么它那么重要。假设有 3 个段落，前后相接，而且都应用以下规则：

```css
/*为简明起见，省略了字体声明*/
p {
    height:50px; 
    border:1px solid #000; 
    backgroundcolor:#fff; 
    margin-top:50px; 
    margin-bottom:30px;
}
```

由于第一段的下外边距与第二段的上外边距相邻，你自然会认为它们之间的外边距是 80 像素（50+30），但是你错啦！它们实际的间距是 50 像素。像这样上下外边距相遇时，它们就会相互重叠，直至一个外边距碰到另一个元素的边框。就上面的例子而言，第二段较宽的上外边距会碰到第一段的边框。也就是说，较宽的外边距决定两个元素最终离多远，没错——50像素。这个过程就叫外边距叠加。

> 注意啦，叠加的只是垂直外边距，水平外边距不叠加。对于水平相邻的元素，它们的水平间距是相邻外边距之和。这跟你最初想的一样。

我想必须得解释一下为什么要让外边距叠加：如果有一连串段落都被应用了相同的样式，那么对其中第一段和最后一段来说，它们的上外边距和下外边距决定 了它们与包含元素的间距。而那些位于中间的段落呢，根本不需要两个外边距加起 来那么宽的间距。因此，就像图 3-7所示的那样，相邻的外边距叠加起来是最合理的， 哪个外边距宽，就以哪个外边距作为段间距。

根据经验，为文本元素设置外边距时通常需要混合使用不同的单位。比如说，一个 段落的左、右外边距可以使用像素，以便该段文本始终与包含元素边界保持固定间 距，不受字号变大或变小的影响。而对于上、下外边距，以 em为单位则可以让段间 距随字号变化而相应增大或缩小，比如：

```css
/*这里使用了简写属性把上、下外边距设置为.75em，把左、右外边距设置为 30 像素*/ 
p {
    font-size:1em; 
    margin:.75em 30px;
}
```

这样，段落的垂直间距始终会保持为字体高度的四分之三（上下外边距都是.75em， 叠加后还是.75em）。如果用户增大了字号，那么不仅段落中的文本会变大，**段间距也会成比例变大**。这样，页面的整体布局就会比较协调一致。与此同时，使用像素单位的左、右外边距不会改变。我想，你应该也不会想让字号变化影响到布局宽度吧。

### 3.2 盒子有多大（呢？）

无论是对初学者，还是对专家来说，W3C盒模型的原理都是CSS最难理解的地方。 在接下来的讨论中，我们将分别介绍块级元素（比如标题、段落和列表）和行内元素的不同行为。

首先，谈一谈设定盒子的宽度，因为控制元素的宽度是创建多栏布局的头等大事。一开始我们会看到给没有宽度的元素添加边框、内边距和外边距的效果，然后再看看通过CSS给它设置了宽度之后，它的行为有什么不一样。

#### 1.没有显式设置宽度的盒子

如果不设置块级元素的 width 属性，那么这个属性的默认值是 auto，结果会让元素的宽度扩展到与父元素同宽。

盒模型结论一：没有（就是没有设置 width 的）宽度的元素始终会扩展到填满其父元素的宽度为止。添加水平边框、内边距和外边距，会导致内容宽度减少，减少量等于水平边框、内边距和外边距的和。

#### 2.有宽度的盒子

盒模型结论二：为设定了宽度的盒子添加边框、内边距和外边距，会导致盒子扩展 得更宽。实际上，盒子的 width 属性设定的只是盒子内容区的宽度，而非盒子要占 据的水平宽度。

宽度非常重要：在多栏布局中，每一栏都必须时刻维护自己的宽度。第 5章将会讨论的“浮动布局”，在列宽由于边框、内边距和外 边距被修改而意外加宽的情况下，会出现显示错误。

> CSS3新增了一个 box-sizing 属性，通过它可以将有宽度的盒子也设定成具有默认的 auto 状态下的行为。但只有最新版本的浏览器才支持该属性，所以在本书写作时 （2012年夏天），我还不能推荐你使用它。

总之要记住一点：设定了元素的 width 属性后，再给元素添加边框、内边距和 外边距，元素的行为与默认的 auto 状态下会有截然不同的表现

### 3.3 浮动float与清除clear

浮动，意思就是把元素从常规文档流中拿出来。

拿出来干什么？

* 一是可以实现传统出版物上那种文字绕排图片的效果；
* 二是可以让原来上下堆叠的块级元素，变成左右并列，从而实现布局中的分栏。

浮动元素脱离了常规文档流之后，原来紧跟其后的元素就会在空间允许的情况下， 向上提升到与浮动元素平起平坐。

如果浮动元素后面有两个段落，而你只想让第一段与浮动元素并列（就算旁边还能放下第二段，也不想让它上来），怎么办？用 clear 属性来“清除”第二段，然后它就乖乖地呆在浮动元素下面了。

> 影响浮动的因素还有很多，推荐读者看一看Eric Meyer的那本Cascading Style Sheets 2.0 Programmer’s Reference（2006，McGraw-Hill Osborne Media）。这本书涵盖了 CSS 运行机制的方方面面，其中很多在别的书里是找不到的。

虽然浮动元素是必要的也是非常有用的 CSS技术，但浮动之后可能带来各种令 CSS初学者困惑的问题。毕竟，浮动的内容已经脱离了文档流，因而无论原先在标记中包含它还是跟随它的元素，其布局都会受到它的影响。

#### 浮动

CSS 设计 float 属性的主要目的，是为了实现文本绕排图片的效果。然而，这个属 性居然也成了创建多栏布局最简单的方式。我们从实现文本绕排图片的效果开始。

为了实现文本绕排图片的浮动效果，必须在标记中先写图片，然后再写环绕它的文本：

```html
<img …… /> 
<p>…the paragraph text…</p>
```

```css
/*为简明起见，省略了字体声明*/ 
p {
    margin:0; 
    border:1px solid red;
} 

img {
    float:left; 
    /*外边距防止图片紧挨文本*/ 
    margin:0 4px 4px 0;
}
```

以上规则会让图片浮动到左侧，从而让文本绕排到右侧。

**说得形象一点，在你浮动一张图片或者其他元素时，你是在要求浏览器把它往上方 推，直到它碰到父元素（也就是 body 元素）的内边界。**

后面的段落（带灰色边框） 不再认为浮动元素在文档流中位于它的前面了，因而它会占据父元素左上角的位置。 不过，它的内容（文本）会绕开浮动的图片。

> 浮动非图片元素时，必须给它设定宽度，否则后果难以预料。图片无所谓，因为它本身有默认的宽度。

在此基础上创建多栏，只要再用一次 float 属性，就这么简单。如图 3-17所示，只要给段落设定宽度，然后也浮动它即可。

```css
p {
    /*这里*/
    float:left; 
    margin:0; 
    width:200px;
    border:1px solid red;
} 

img {
    float:left; 
    margin:0 4px 4px 0;
}
```

浮动图片旁边的固定宽度段落一经浮动，就会变成布局中的一栏， 其文本也不会再绕排图片了。（图片自己去书里看~）

你这样同时浮动图片和“有宽度的”段落，会导致段落的文本绕排效果消失，而浮 动的段落也会尽可能向左向上移动。就这样，这个段落就构成了紧挨着图片的一栏。 这就是使用 float 属性创建多栏布局的原理。**换句话说，如果几个相邻的元素都具有设定的宽度，都是浮动的，而且水平空间也足以容纳它们，它们就会并列排在一行。**

**如果你创建了三个浮动、固定宽度的元素，它们就会像这样并排在一行，构成三栏布局的框架。每个元素都可以作为容器，包含其他元素。**

接下来我们再看看浮动的另一面，这也是必须得理解的。浮动元素位于“文档流外 部”，因而它已经不被包含在标记中的父元素之内了。正因为如此，它对布局可能产生破坏性影响。

#### 围住浮动元素的三种方法

浮动元素脱离了文档流，其父元素也看不到它了，因而也不会包围它。

这种情况有时候并非我们想要的，本节向大家传授三种围住浮动子元素的方法。记住，这三种方法你都得掌握，这样才能审时度势，选择最合适的一种。

我们首先要从一张带标题的图片开始。图片和标签包含在一个 section 元素中，而 section 元素后面跟着一个 footer 元素。可以把这个 footer 元素想象成很多网页底部都会有的与页面同宽的页脚。

```html
<section>
    <img src="images/rubber_duck2.jpg"> 
    <p>It's fun to float.</p>
</section> 
<footer> Here is the footer element that runs across the bottom of the page.</footer>
```

```css
section {
    border:1px solid blue; 
    margin:0 0 10px 0;
}
/*删除默认的上下外边距*/ 
p {
    margin 0;
}
/*为简明起见，省略了字体声明*/ 
footer {
    border:1px solid red;
}
```

现在我们看到的是常规文档流，即块级元素包围着所有子元素，而且在页面中自上而下相互堆叠在一起。

假设我们想让图片标题位于图片右侧，而不是像现在这样位于下方。运用刚刚学到的知识，我们知道实现这个目标最简单的方式就是浮动图片：

```css
section {
    border:1px solid blue; 
    margin:0 0 10px 0;
} 
img {
    float:left;
} 
footer {
    border:1px solid red;
}
```

浮动图片后标题跑到了右边，但父元素 section 也收缩到只包含文本的高度高度。

标题倒是跑到右边了，可 section 也不再包围浮动元素了，它只包围非浮动的元素。于是，footer 被提了上来，紧挨着前一个块级元素——section。这样是没错 儿，可结果呢，不是我们想要的。

##### 方法一：为父元素添加overflow:hidden

第一个方法很简单，缺点是不太直观，即为父元素应用 overflow:hidden，以强制它包围浮动元素。

```css
section {
    border:1px solid blue; 
    margin:0 0 10px 0; 
    overflow:hidden;
}
img {
    float:left;
} 
p {
    border:1px solid red;
}
```

把 overflow:hidden 声明应用到容器元素后，footer 又回到了我们期望的位置。

给容器元素应用 overflow:hidden 声明后，它又包围了浮动元素。

实际上，overflow:hidden 声明的真正用途是防止包含元素被超大内容撑大。应用 overflow:hidden 之后，包含元素依然保持其设定的宽度，而超大的子内容则会被容器剪切掉。**除此之外，overflow:hidden 还有另一个作用，即它能可靠地迫使父元素包含其浮动的子元素。**

##### 方法二：同时浮动父元素

第二种促使父元素包围其浮动子元素的方法，是也让父元素浮动起来。

```css
section {
    border:1px solid blue; 
    float:left; 
    width:100%;
} 
img {
    float:left;
} 
footer {
    border:1px solid red; 
    clear:left;
}
```

浮动 section 以后，不管其子元素是否浮动，它都会紧紧地包围（也称收缩包裹）住它的子元素。

因此，需要用 width:100% 再让 section 与浏览器容器同宽。另外，由于 section 现在也浮动了，所以 footer 会努力往上挤到它旁边去。为了强制 footer 依然呆在 section 下方，要给它应用 clear:left。被清除的元素不会被提升到浮动元素的旁边。以上代码能得到与图 3-20相同的效果。

##### 方法三：添加非浮动的清除元素

第三种强制父元素包含其浮动子元素的方法，就是给父元素的最后添加一个非浮动的子元素，然后清除该子元素。

由于包含元素一定会包围非浮动的子元素，而且清除会让这个子元素位于（清除一侧）浮动元素的下方，因此包含元素一定会包含这个子元素——以及前面的浮动元素。

在包含元素最后添加子元素作为清除元素的方式有两种。

第一种方式不太理想，也就是简单地在 HTML标记中添加一个子元素，并给它应用 clear 属性。由于没有默认的样式，不会引入多余空间，div 元素很适合这个目的。

```html
<section> 
    <img src="images/rubber_duck.jpg"> 
    <p>It's fun to float.</p> 
    <div class="clear_me"></div>
</section> 
<footer> Here is the footer element…</footer>
```

```css
section {
    border:1px solid blue;
}
img {
    float:left;
} 
.clear_me {
    clear:left;
} 
footer {
    border:1px solid red;
}
```

这样，浮动的元素被父元素包围住了，结果如图 3-20所示。如果你特别不想添加这 个纯表现性元素，我再告诉你一个用 CSS来添加这个清除元素的方法。

首先，要给 section 添加一个类。

```html
<section class="clearfix"> 
    <img src="images/rubber_duck.jpg"> 
    <p>It's fun to float.</p>
</section> 
<footer> Here is the footer element…</footer>
```

```css
.clearfix:after { 
    content:"."; 
    display:block; 
    height:0;          //可以删除看看
    visibility:hidden; //可以删除看看 
    clear:both;
}
```

这个规则最早是由程序员 Tony Aslett 发明的，它只添加了一个清除的包含句点作为非浮动元素（必须得有内容，而句点是最小的内容）。规则中的其他语句是为了确保这个伪元素没有高度，而且在页面上不可见。

使用clear:both意味着section中新增的子元素会清除左、右浮动元素（位于左、右浮动元素下方）。这里当然可以只用 left，但both也适用于将来图片 float:right的情况。

同样，浮动的元素又像图 3-20所示的一样被包围住了，但这次标记里没有额外硬编码的元素。好奇的话，你可以临时把 clearfix规则中的 height 和 visibility 声明删除，看一看通过伪元素添加到标记中的句点。

我在自己写的所有网站中都使用 clearfix 规则来解决浮动问题，因为浮动是实现多栏 布局（在更多浏览器支持 CSS3的Multi-column Layout Module之前）唯一最可靠的方式。

#### 总结

要想强迫父元素包围其浮动的子元素有三种方式， 哪三种？

* 为父元素应用 overflow:hidden
* 浮动父元素
* 在父元素内容的末尾添加非浮动元素，可以直接在标记中加，也可以通过给父元素添加 clearfix 类来加（当然，样式表中得需要相应的 clearfix规则）

这三种方法的使用要因地制宜。

比如，不能在下拉菜单的顶级元素上应用 overflow:hidden，否则作为其子元素的下拉菜单就不会显示了。因为下拉菜单会显 示在其父元素区域的外部，而这恰恰是 overflow:hidden 所要阻止的。

再比如，不能对已经靠自动外边距居中的元素使用“浮动父元素”技术，否则它就不会再居中，而是根据浮动值浮动到左边或右边了。

#### 没有父元素时如何清除

有时候，在清除某些浮动元素时，不一定正好有那么个父元素可以作为容器来强行包围它们。此时，最简单的办法就是给一个浮动元素应用 clear:both，强迫它定位在前一个浮动元素下方。然而，在空间足以容纳多个元素向上浮动时，这个简单的办法未必奏效，我们还得另辟蹊径。

为了演示这种情况，图 3-21 展示了一个页面，其中包含 6 个元素：3 张图片和介绍它们的 3 个文本段落。这个页面布局是通过浮动图片实现的，因此在标记中跟在图片后面的文本会向上走，停靠在浮动图片的右侧。

以下为对应的代码：

```html
<section> 
    <img src="images/rubber_duck3.jpg"> 
    <p>This text sits next to the image and because the…</p>
    <img src="images/beach_ball.jpg">
    <p>This text is short, so the next image can float up…</p>
    <img src="images/yellow_float.jpg"> 
    <p>Because the previous image’s text does not…</p>
</section>
```

```css
section {
    width:300px; 
    border:1px solid red;
}
img {
    float:left; 
    margin:0 4px 4px 0;
}
/*为简明起见，省略了字体声明*/ 
p {
    margin:0 0 5px 0;
}
```

我们的目标是让每段文字停靠在相应的图片旁边。然而，第二段文字太短了，都没有够到第二张浮动图片的下沿。这就给下一对儿图片/段落向上浮动留出了空间。

这个例子中的布局效果从技术角度看是正确的：第三对儿图片/段落有条件（有空 间）停靠在第二张浮动图片旁边，于是它们就毫不客气地靠了过去。毕竟，浮动元素的使命不就是尽可能地向左上或右上迁移吗？可这个视觉上的结果却不是我们想要的。

由于每一对儿图片/段落都没有包含元素，在此就无法使用前面讨论的“强制父元素包围”的战术。不过，我照样可以使用 clearfix 规则呀！

```css
.clearfix:after { 
    content:"."; 
    display:block; 
    height:0; 
    visibility:hidden;
    clear:both;
}
```

像这样给每个段落都加上 clearfix 类：

```html
<section> 
    <img src="images/rubber_duck3.jpg"> 
    <p class="clearfix">This text sits next to the image and because the…</p> 
    <img src="images/beach_ball.jpg"> 
    <p class="clearfix">This text is short, so the next image can float up…</p> 
    <img src="images/yellow_float.jpg"> 
    <p class="clearfix">Because the previous image's text does not…</p>.
</section>
```

在每个段落内容的最后添加了“清除子元素”，我们想要的布局效果实现了。

因为第三对儿图片和段落前面增加了一个清除元素，所以它们就不能再往上走了。注意，我没有只给第二个段落添加 clearfix 类，而是每个段落都加上了一个。如果是真正的网站开发，就得这么做啊。这样，无论将来哪个段落的文本高度低于图片了，页面布局都不会被破坏。

### 3.4 定位position

position 属性有4个值：static、relative、absolute、fixed，默认值为 static。

#### static

在静态定位的情况下，每个元素在处在常规文档流中。它们都是块级元素，所以就会在页面中自上而下地堆叠起来。

#### relative（最常用）

到底相对哪里定位呢？相对的是它原来在文档流中的位置（或者默认位置）。

可以使用 top、right、 bottom 和 left 属性来改变它的位置了。但多数情况下，只用 top 和 left 就可以实现我们想要的效果。

```css
p#specialpara {
    position:relative; 
    top:25px; 
    left:30px;
}
```

> 可以给 top 和 left 属性设定负值，把元素向上、向左移动。

要注意，除了这个元素自己相对于原始位置挪动了一下之外，页面没有发生任何变化。换句话说，这个元素原来占据的空间没有动，其他元素也没动。

使用相对定位的关键是什么呢？就是要考虑到元素原来的空间。

#### absolute

绝对定位跟静态定位和相对定位比，绝对不一样。因为绝对定位会把元素彻底从文档流中拿出来。

可以看到元素之前占据的空间被“回收了”。这说明，绝对定位的元素完全脱离了常规文档流，它现在是相对于顶级元素 body 在定位。而这自然而然就引出了一个关于定位的重要概念：定位上下文。

首先我们要知道绝对定位元素默认的定位上下文是 body 元素。通过 top 和 left 设定的偏移值，决定了元素相对于 body 元素（标记 层次中的祖先容器），而不是相对于它在文档流中的位置偏移多远——这一点与相对定位的元素不同。

注意：由于绝对定位元素的定位上下文是 body，所以在页面滚动的时候，为了维护与 body 元素的相对位置关系，它也会相应地移动。

#### fixed

从完全移出文档流的角度说，固定定位与绝对定位类似。

但不同之处在于，固定定位元素的定位上下文是视口（浏览器窗口或手持设备的屏幕），因此它不会随页面滚动而移动。

固定定位并不常用，最常见的情况是用它创建不随页面滚动而移动的导航元素。

#### 定位上下文

我们知道绝对定位元素默认的定位上下文是 body，这是因为 body是标记中所有元素唯一的祖先元素。

而实际上，绝对定位元素的任何祖先元素都 可以成为它的定位上下文，**只要你把相应祖先元素的 position 设定为 relative 即可。**

```html
<body>
    <div id="outer">
        <div id="inner">This is text…</div>
    </div>
</body>
```

```css
div#outer {
    width:250px; 
    margin:50px 40px;
    border-top:3px solid red;
} 
div#inner {
    top:10px; 
    left:20px; 
    background:#ccc;
}
```

看到代码里给内部 div 设定了 top 和 left 属性，为 什么内部 div 没有相对外部 div 向下移动10像素，向右移动20像素呢？为什么它们 俩的原点（左上角点）还一样呢？原因在于，内外部 div 默认都是静态定位，它们之间不存在谁是谁的定位上下文这个问题。

换句话说，在常规文档流中，由于外部 div 没有内容，内部 div 就会跟它共享相同的起点。只有将元素的 position 属性设定为 relative、absolute 或 fixed，这个元素的 top、right、bottom 和 left 属性才会起作用。

改为绝对定位：

```css
div#outer {
    width:250px; 
    margin:50px 40px;
    border-top:3px solid red;
} 
div#inner {
    position:absolute;
    top:10px; 
    left:20px; 
    background:#ccc;
}
```

inner绝对定位是相对于谁？由于没有相对定位的祖先元素供其参照，内部 div 只 能以默认的定位上下文 body 作为参照，相对于它定位。

此时，内部 div 完全无视其父元素（外部 div）的存在，top 和 left 属性会相对于 body 元素向下、向左偏移其位置。

> 事实上，只要把元素的外边距和内边距设定好，多数情况下只用静态定位就足以实现页面布局了。很多刚开始接触CSS的初学者都会错误地设定 position 属性，最终才发现从文档流中挪出来的这些元素一点也不好控制。因此，除非真需要那么做，否则不要轻易修改元素默认的 position 属性。

如果我现在把外部 div 的 position 属性设定为 relative：

```css
div#outer {
    position:relative;
    width:250px; 
    margin:50px 40px;
    border-top:3px solid red;
} 
div#inner {
    position:absolute;
    top:10px; 
    left:20px; 
    background:#ccc;
}
```

这样内部 div 的定位上下文就变成了外部 div。

此时内部 div 的 top 和 left 属性参照的就是外部 div 了。如果你再用 left 和 top 属性重新定位外部 div，内部 div 也会跟着移动相同的距离，以保证它与外部 div（也就是它的定位上下文）之间的位置关系。

### 3.5 display

正如所有元素都有 position 属性，所有元素也都有 display 属性。

尽管 display 属性的值有很多，但大多数元素 display 属性的默认值不是 block，就是 inline。

把块级元素变成行内元素（或者相反）的魔法如下：

```css
/*默认为 block*/ 
p {
    display:inline;
} 
/*默认为 inline*/ 
a {
    display:block;
}
```

这种转换可以让原先的行内元素填满其父元素。本书后面在介绍到 CSS下拉菜单的时候，就会用到这个技巧。

display 属性还有一个值有必要提一下，就是 none。把元素的 display 设定为 none，该元素及所有包含在其中的元素，都不会在页面中显示。它们原先占据的所有空间也都会被“回收”，就好像相关的标记根本不存在一样。与此相对的是 visibility 属性，这个属性最常用的两个相对的值是 visible（默认值）和 hidden。把元素的 visibility 设定为 hidden，元素会隐藏，但它占据的页面空间仍然“虚位以待”。

### 3.6 background

关于定位元素，最后要讲的一个主题是背景。

背景支持为元素添加背景颜色和背景图片。

每个元素盒子都可以想象成由两个图层组成。元素的前景层包含内容（如文本或图片）和边框，元素的背景层可以用实色填充（使用 background-color 属性），也可以包含任意多个背景图片（使用 background-image 属性），背景图片叠加在背景颜色之上。

> 在 CSS3被浏览器实现之前，只能在背景颜色上添加一张背景图片。而现在，我们可以为背景图层添加多张图片（以及 CSS3渐变）。

* background-color：
* background-image
* background-repeat  background-position  background-size  background-attachment  background（简写属性）  background-clip、background-origin、background-break（目前尚未得到广泛支持）

## 5、页面布局

