# 细碎知识点合集

## div标签到底可以加什么？

class可以给 div 这个块区域加上一个名称，例如

```html
<div class="caifanghan">
</div>
```

你可以拿到这个 class 名称来设置一些样式。

很容易弄混的就是class和id：

* id具有唯一性，在一个网页中只能使用一次；class可以使用多次。
* id在CSS中是使用#开头，class在CSS中是使用.开头。id会调用#开头的CSS，class是调用.开头的CSS。
* id和class可以在网页中任意标签内使用。一些比较重要的特别的用id，反之用class（自己斟酌）。

:class 用来动态切换class...(前端牛批。。)

* :class = "a"：说明 vue 中有个叫 a 的属性，这个标签的 class 就是 a 的值
* :class = "{ active: isActive }"：active的存在取决于 isActive的值，为true就说明存在，为false就说明不存 在。
* :class="ind.titleSrc?'bgImgSet':''"：如果存在titleSrc 就添加bgImgSet，如果不存在就没有这个class

## v-for一定要和v-bind:key合用

## v-model和v-bind:model(:model)

v-model是vuejs内置的双向数据绑定指令，只用于表单控件（`<input>`、`<textarea>`及`<select>`），对表单控件以外的标签不起作用。

v-bind:model相当于:model，只是v-bind动态绑定指令，默认情况下标签自带属性的值是固定的，这种只是把父组件的数据传递给了子组件，没有实现子组件和父组件数据的双向绑定。引用类型除外，当子组件改变引用类型的数据的话，父组件也会改变。

```html
<input v-model="message"> 
 =
<input v-bind:value="message" v-on:input="message = $event.target.value" />
```

上面这个例子中，v-bind:value="message" 只是将message变量的值赋给了input的value，
并没有双向绑定，再此声明一下以防混淆。

### 补充

v-model本质上是语法糖，如下代码：

```html
<input v-model="test">
```

本质上等于：

```html
<input :value="test" @input="test = $event.target.value"
```

其中@input是对 `<input>` 输入事件的一个监听，:value="test"是将监听事件中的数据放入到input。

> v-model用于表单数据的双向绑定，其实它就是一个语法糖，这个背后就做了两个操作：
>
> 1. v-bind绑定一个value属性
> 2. v-on指令给当前元素绑定input事件

在这边需要强调一点，v-model不仅可以给input赋值还可以获取input中的数据，而且数据的获取是实时的，因为语法糖中是用@input对输入框进行监听的。

## data的不同写法

在简单的vue实例中看到的Vue实例中data属性是如下方式展示的：

```javascript
let app = newVue({
 
    el:"#app",
    data:{
        msg:''
    },
    methods:{
       
    }
})
```

在使用组件化的项目中使用的是如下形式：

```javascript
export default{
    data(){
        return {
            showLogin:true,
            // def_act: '/A_VUE',
            msg: 'hello vue',
            user:'',
            homeContent: false,
        }
    },
    methods:{
       
    }
}
```

为何在大型项目中data需要使用return返回数据呢？

原因：不使用return包裹的数据会在项目的全局可见，会造成变量污染；使用return包裹后数据中变量只在当前组件中生效，不会影响其他组件。

这种方式是为了防止，在同一个页面内多次引用同一个子组件，其中一个组件参数发生改变会造成其他组件参数的同时改变(这也是VUE中的数据双向绑定)，而使用return一个初始数据对象的函数，是把最初子组件定义的初始值进行复制。

并且**注意：**第一种写法在export default里会出错，导致界面无法渲染！所以统一使用第二种写法（data以方法形式出现）

## key标签

在vue的文档中，key被用来表示是否要复用的情况：https://cn.vuejs.org/v2/guide/conditional.html#%E7%94%A8-key-%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E5%85%83%E7%B4%A0

## v-show标签

https://cn.vuejs.org/v2/guide/conditional.html#v-if-vs-v-show

## 变更方法

就是会改变原数组的方法，例如push()，pop()等。

非变更的为filter()，concat()，slice()等。

## label标签的for属性

只和input标签一起使用

## Vue生命周期

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script src="./lib/vue-2.4.0.js"></script>
</head>
<body>

  <div id="app">
    <input type="button" value="修改msg" @click="msg='No'">
    <h3 id="h3">{{ msg }}</h3>
  </div>

  <script>
    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: '#app',
      data: {
        msg: 'ok'
      },
      methods: {
        show() {
          console.log('执行了show方法')
        }
      },
      beforeCreate() { // 这是我们遇到的第一个生命周期函数，表示实例完全被创建出来之前，会执行它
        // console.log(this.msg)
        // this.show()
        // 注意： 在 beforeCreate 生命周期函数执行的时候，data 和 methods 中的数据都还没有没初始化
      },
      created() { // 这是遇到的第二个生命周期函数
        // console.log(this.msg)
        // this.show()
        // 在 created 中，data 和 methods 都已经被初始化好了！
        // 如果要调用 methods 中的方法，或者操作 data 中的数据，最早，只能在 created 中操作
      },
      beforeMount() { // 这是遇到的第3个生命周期函数，表示 模板已经在内存中编辑完成了，但是尚未把模板渲染到页面中
        // console.log(document.getElementById('h3').innerText)
        // 在 beforeMount 执行的时候，页面中的元素，还没有被真正替换过来，只是之前写的一些模板字符串
      },
      mounted() { // 这是遇到的第4个生命周期函数，表示内存中的模板，已经真实地挂载到了页面中，用户已经可以看到渲染好的页面了
        // console.log(document.getElementById('h3').innerText)
        // 注意： mounted 是 实例创建期间的最后一个生命周期函数，当执行完 mounted 就表示，实例已经被完全创建好了，此时，如果没有其它操作的话，这个实例，就静静的 躺在我们的内存中，一动不动
      },


      // 接下来的是运行中的两个事件
      beforeUpdate() { // 这时候，表示 我们的界面还没有被更新【数据被更新了吗？数据肯定被更新了】
        /* console.log('界面上元素的内容：' + document.getElementById('h3').innerText)
        console.log('data 中的 msg 数据是：' + this.msg) */
        // 得出结论： 当执行 beforeUpdate 的时候，页面中的显示的数据，还是旧的，此时 data 数据是最新的，页面尚未和 最新的数据保持同步
      },
      updated() {
        console.log('界面上元素的内容：' + document.getElementById('h3').innerText)
        console.log('data 中的 msg 数据是：' + this.msg)
        // updated 事件执行的时候，页面和 data 数据已经保持同步了，都是最新的
      }
    });
  </script>
</body>
```

## computed、watch

https://blog.csdn.net/zhouzy539/article/details/96340814

https://w.cnblogs.com/jin-zhe/p/9319648.html

## axios+promise

https://segmentfault.com/a/1190000016680014